= Processamento Digital de Imagens
:url-peak: https://agostinhobritojr.github.io/tutorial/pdi/exemplos/pixels.cpp
:url-peak1: https://docs.opencv.org/3.4/d2/d44/classcv_1_1Rect__.html
:url-peak2: https://agostinhobritojr.github.io/tutorial/pdi/exemplos/labeling.cpp
:url-peak3: https://agostinhobritojr.github.io/tutorial/pdi/exemplos/filtroespacial.cpp
Por Sthefania Fernandes <sthefaniafernandes03@gmail.com> 
graduanda em Engenharia Mecatrônica pela UFRN
:toc: left
:toc-title: Sumário

== Introdução

Este site tem por objetivo documentar a solução dos exercícios da disciplina Processamento Digital de Imagens (DCA0445) ministrada pelo professor Agostinho Brito Jr. e disponível em https://agostinhobritojr.github.io/tutorial/pdi/.


Todos os exercícios foram desenvolvidos usando a API C++ do OpenCV — https://opencv.org/  — e foram testados em um ambiente executando o sistema operacional Linux (Ubuntu 20.04.6).


== 1 Manipulando pixels de uma imagem

=== 1.1 Negativo de uma região

Utilizando o programa {url-peak}[exemplos/pixels.cpp] como referência, foi implementado o programa regions.cpp. 

Esse programa irá solicitar ao usuário as coordenadas de dois pontos (P1 e P2), os quais devem localizar-se dentro do limites de tamanho da imagem. Essa região, definida pelos pontos P1 e P2, será exibida com o negativo da imagem utilizada pelo programa. 

O algoritmo desenvolvido pode ser visualizado abaixo:

.Código 1: regions.cpp

[source, cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

/*
Essa função foi feita para definir o funcionamento correto do for que tornará a imagem negativa. Afinal ele percorre do menor valor para o maior, incrementando a cada iteração, então é preciso garantir que ele inicie a contagem da menor coordenada para maior.
*/
void troca_val(int *a, int *b){

    int aux=0;

    if ((*a)>(*b)){
        aux=*a;
        *a=*b;
        *b=aux;
    }
    else
        return;
}

int main (){

    cv::Mat image;
    cv::Vec2i p1;
    cv::Vec2i p2;

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);
    if(!image.data)
        std::cout << "A imagem nao abriu" << std::endl;
    
    cv::namedWindow("Recorte negativo", cv::WINDOW_AUTOSIZE);

    std:: cout << "O tamanho da imagem é: " << image.rows << "x"<< image.cols << std:: endl;
    std:: cout << "Insira 2 pontos dentro do limite." << std:: endl;

    /*
    o do-while é utilizado para impedir que se insira uma coordenada fora do tamanho da imagem
    */

    do {
        std::cout << "Insira a coordenada x do 1º ponto:" << std:: endl;
        std::cin >> p1[0];
    } while (p1[0]>=image.rows);

    do {
        std::cout << "Insira a coordenada y do 1º ponto:" << std:: endl;
        std::cin >> p1[1];
    } while (p1[1]>=image.cols);
    
    do {
        std::cout << "Insira a coordenada x do 2º ponto:" << std:: endl;
        std::cin >> p2[0];
    } while (p2[0]>=image.rows);

    do {
        std::cout << "Insira a coordenada y do 2º ponto:" << std:: endl;
        std::cin >> p2[1];
    } while (p2[1]>=image.cols);

    /*
    se a coordenada x1 e x2  ou y1 e y2 forem iguais a condição do for não é atendida e a imagem  não ficará negativa, então se alguém preencher dessa forma o programa será encerrado com aviso de erro.
    */

    if (p1[0]==p2[0]|| p1[1]==p2[1]){
        std:: cout<< "Erro: coordenadas inválidas. x1 deve ser diferente de x2, y1 deve ser diferente de y2." << std:: endl;
        return 0;
    }

    troca_val(&p1[0],&p2[0]);
    troca_val(&p1[1],&p2[1]);
    
    for(int i=p1[0]; i<p2[0]; i++){
        for(int j=p1[1]; j<p2[1]; j++){
            image.at<uchar>(i,j)= 255 - image.at<uchar>(i,j);
        }
    }

    cv::imshow("Recorte negativo", image);  
    cv::waitKey();

    return 0;
}
----

A parte principal desse código é definir o negativo da imagem. Isso é feito subtraindo de 255 (equivalente a cor branca em uma imagem) o valor do pixel que você quer deixar negativo. Aqui os pixels que se tornarão negativos são os definidos pelos 2 pontos inseridos pelo usuário e estes são usados como inicio e fim do laço que realiza a alteração da imagem.

.Código 2: Negativo de uma imagem

[source, cpp]
----
for(int i=p1[0]; i<p2[0]; i++){
        for(int j=p1[1]; j<p2[1]; j++){
            image.at<uchar>(i,j)= 255 - image.at<uchar>(i,j);
        }
    }
----

A imagem utilizada nesse código é a mostrada abaixo:

.Imagem original
image::figuras/biel.png[]

A saída do programa será uma imagem com uma parte negativa definida pelos pontos inseridos pelo usuário. A imagem original não será alterada e ao pressionar uma tecla qualquer do teclado a imagem negativa será fechada e não será salva. 

Abaixo temos duas imagens obtidas com esse programa. A primeira utiliza os pontos (50,70)(160,30) e a segunda (50,100)(200,200).

.Resultados do algoritmo
image::figuras/negativos.png[width=500,height=500]

=== 1.2 Troca de Quadrantes

Por meio do programa {url-peak}[exemplos/pixels.cpp], foi implementado um programa que troca quatro quadrantes de uma imagem. 

No código foi utilizada a função {url-peak1}[rect] do OpenCV para extrair regiões de uma imagem. Cada região extraída foi salva em uma nova matriz (Q1, Q2, Q3,e Q4). Utilizando a função copyTo os recortes salvos foram inseridos na matriz trocaquadrante em posições diferentes da imagem original.

O algoritmo desenvolvido pode ser visualizado abaixo:

.Código 3: trocaregioes.cpp
[source, cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main (){
    /*Definindo imagem original*/
    cv::Mat image;
    /*Definindo imagem com os quadrantes mudados.
      Ela terá o mesmo número de linhas e colunas da imagem
      original e o mesmo tipo*/

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);

    if(!image.data)
        std::cout << "A imagem nao abriu" << std::endl;
    
    cv::namedWindow("Imagem original", cv::WINDOW_AUTOSIZE);
    cv::imshow("Imagem original", image);  
    cv::waitKey();

    cv::Mat trocaquadrante(image.rows, image.cols, image.type());

    /*quadrante superior esquerdo*/
    cv::Mat Q1 = image(cv::Rect(0, 0, image.rows/2, image.cols/2)); 
    /*quadrante inferior esquerdo*/
    cv::Mat Q2 = image(cv::Rect(0, image.cols/2, image.rows/2, image.cols/2));
    /*quadrante superior direito*/   
    cv::Mat Q3 = image(cv::Rect(image.rows/2, 0, image.rows/2, image.cols/2));
    /*quadrante inferior direito*/
    cv::Mat Q4 = image(cv::Rect(image.rows/2, image.cols/2, image.rows/2, image.cols/2));

    Q4.copyTo(trocaquadrante(cv::Rect(0,0,image.rows/2,image.cols/2)));
    Q3.copyTo(trocaquadrante(cv::Rect(0,image.cols/2,image.rows/2,image.cols/2)));
    Q2.copyTo(trocaquadrante(cv::Rect(image.rows/2,0,image.rows/2,image.cols/2)));
    Q1.copyTo(trocaquadrante(cv::Rect(image.rows/2,image.cols/2,image.rows/2,image.cols/2)));


    cv::namedWindow("Imagem trocada", cv::WINDOW_AUTOSIZE);
    cv::imshow("Imagem trocada", trocaquadrante);
    cv::waitKey();
   
    return 0;
}
----

Como resultado do programa, obtivemos as imagens abaixo:

.Imagem original e imagem com quadrantes trocados
image::figuras/trocarregioes.png[width=500,height=500]

== 2 Serialização de dados em ponto flutuante via FileStorage

== 3 Decomposição de imagens em planos de bits


== 4 Preenchendo regiões
=== 4.1 Identificando bolhas com ou sem buracos

Aprimorando o algoritmo {url-peak2}[labeling.cpp], o objetivo agora é identificar regiões com ou sem buracos internos que existam na imagem. Para isso, vamos assumir que objetos com mais de um buraco podem existir e que não devemos contar bolhas que tocam as bordas da imagem.

Abaixo temos o algoritmo completo que foi implementado.

.Código 4: buracosebolhas.cpp

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

using namespace cv;

int main(int argc, char** argv) {
    cv::Mat image;
    int width, height;
    int total_bolhas=0;
    int bolhas_cm_buraco=0;
    int bolhas_na_borda=0;

    cv::Point p;
    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

    if (!image.data) {
        std::cout << "imagem nao carregou corretamente\n";
        return (-1);
    }

    cv::imshow("Imagem original", image);
    cv::imwrite("original.png", image);
    cv::waitKey();

    width = image.cols;
    height = image.rows;
    std::cout << width << "x" << height << std::endl;

    p.x = 0;
    p.y = 0;

    /*
    Removendo bolhas das bordas: 
    o loop verifica os bjetos presentes nas bordas 
    e pinta de preto
    */ 
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (i == 0 || i == (height - 1) || j == 0 || j == (width - 1))
            {
                if (image.at<uchar>(i, j) == 255)
                {
                    p.x = j;
                    p.y = i;
                    bolhas_na_borda++;
                    cv::floodFill(image, p, 0);
                }
            }
        }
    }

    cv::imshow("Sem bolhas na borda", image);
    cv::imwrite("borda.png", image);
    cv::waitKey();

    /*
    Contar bolhas com buraco: primeiro mudo a cor do fundo para
    um tom de cinza (100), assim só restará a cor preta dentro
    das bolhas com buraco permitindo a contagem.
    Depois o buraco é pintado de branco
    */
    p.x = 0;
    p.y = 0;
    cv::floodFill(image, p, 100);
    cv::imshow("Bolhas com buraco", image);
    cv::imwrite("buraco.png", image);
    cv::waitKey();

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (image.at<uchar>(i, j) == 0)
            {
                p.x = j;
                p.y = i;
                bolhas_cm_buraco++;
                cv::floodFill(image, p, 255);
            }
        }
    }

    p.x = 0;
    p.y = 0;
    /*volta o fundo para a cor original (preto)*/
    cv::floodFill(image, p, 0);

    /*
    utilizando o algoritmo labeling conto o total de bolhas na imagem
    */

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (image.at<uchar>(i, j) == 255)
            {
                // achou um objeto
                total_bolhas++;
                // para o floodfill as coordenadas
                // x e y são trocadas.
                p.x = j;
                p.y = i;
                // preenche o objeto com o contador
                cv::floodFill(image, p, total_bolhas);
            }
        }
    }
    
    int bolhas_sem_buraco=total_bolhas-bolhas_cm_buraco;

    cv::imshow("Bolhas", image);
    cv::imwrite("Bolhas.png", image);
    cv::waitKey();
    
    std::cout << "Total de bolhas na imagem: " << total_bolhas << std:: endl;
    std::cout << "Bolhas com buraco: " << bolhas_cm_buraco << std:: endl;
    std::cout << "Bolhas sem buraco: " << bolhas_sem_buraco << std:: endl;
    std::cout << "Bolhas que estavam na borda: " << bolhas_na_borda << std:: endl;
    
    return 0;
}
----

A cada mudança significativa foi gerada uma imagem. Assim, começamos mostrando como é a imagem original rotulada pelo programa.

.Imagem original bolhas.png
image::figuras/bolhas.png[width=300,height=300]

Com a retirada das bolhas contidas na borda da imagem, é gerada a segunda imagem:

.Imagem sem bolhas na borda
image::figuras/semborda.png[width=300,height=300]

Para identificar quais bolhas possuíam buracos, a cor do fundo foi mudada de preto para um tom de cinza. Isso foi feito para que somente os buracos ficassem na cor preta, assim a imagem foi varrida e foi possível identificar a quantidade de bolhas com buraco.

.Bolhas com buraco
image::figuras/buracos.png[width=300,height=300]

Em adição, os buracos foram removidos e a quantidade total de bolhas restantes foi contada. Além disso, o fundo voltou a ser preto permitindo que o labeling fosse  aplicado. A imagem final gerada pode ser vista abaixo:

.Resultado final do programa
image::figuras/bolhaslab.png[width=300,height=300]

No fim, o código exibe como resposta os seguintes dados:

----
Total de bolhas na imagem: 21
Bolhas com buraco: 7
Bolhas sem buraco: 14
Bolhas que estavam na borda: 11
----

== 5 Manipulação de histogramas


== 6 Filtragem no domínio espacial I
=== 6.1 Laplaciano do gaussiano de um vídeo

Utilizando o programa {url-peak3}[filtroespacial.cpp] como referência, foi implementadod o programa laplgauss.cpp. 

O programa acrescenta uma nova funcionalidade ao exemplo fornecido, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas. 

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

void printmask(cv::Mat &m) {
  for (int i = 0; i < m.size().height; i++) {
    for (int j = 0; j < m.size().width; j++) {
      std::cout << m.at<float>(i, j) << ",";
    }
    std::cout << "\n";
  }
}

int main(int, char **) {
  cv::VideoCapture cap;  // open the default camera
  float media[] = {0.1111, 0.1111, 0.1111, 0.1111, 0.1111,
                   0.1111, 0.1111, 0.1111, 0.1111};
  float gauss[] = {0.0625, 0.125,  0.0625, 0.125, 0.25,
                   0.125,  0.0625, 0.125,  0.0625};
  float horizontal[] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
  float vertical[] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
  float laplacian[] = {0, -1, 0, -1, 4, -1, 0, -1, 0};
  float boost[] = {0, -1, 0, -1, 5.2, -1, 0, -1, 0};
  float laplgauss [] ={0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,16,-2,-1,
                      0,-1,-2,-1,0,0,0,-1,0,0};

  cv::Mat frame, framegray, frame32f, frameFiltered;
  cv::Mat mask(3, 3, CV_32F), mask_scale;
  cv::Mat result;
  double width, height;
  int absolut;
  char key;

  cap.open("paisagem.mp4");

  if (!cap.isOpened())  // check if we succeeded
    return -1;

  cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
  cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
  width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
  height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
  std::cout << "largura=" << width << "\n";
  std::cout << "altura =" << height << "\n";
  std::cout << "fps    =" << cap.get(cv::CAP_PROP_FPS) << "\n";
  std::cout << "format =" << cap.get(cv::CAP_PROP_FORMAT) << "\n";
  std::cout << "\nPressione as teclas para ativar o filtro: \n"
          "a - calcular módulo\n"
          "m - média\n"
          "g - gauss\n"
          "v - vertical\n"
          "h - horizontal\n"
          "l - laplaciano\n"
          "x - laplaciano do gaussiano\n"
          "esc - encerrar\n";

  cv::namedWindow("filtroespacial", cv::WINDOW_NORMAL);
  cv::namedWindow("original", cv::WINDOW_NORMAL);

  mask = cv::Mat(3, 3, CV_32F, media);
  absolut = 1;  // calcs abs of the image

  for (;;) {
    cap >> frame;  // get a new frame from camera
    cv::cvtColor(frame, framegray, cv::COLOR_BGR2GRAY);
    cv::flip(framegray, framegray, 1);
    cv::imshow("original", framegray);
    framegray.convertTo(frame32f, CV_32F);
    cv::filter2D(frame32f, frameFiltered, frame32f.depth(), mask,
                 cv::Point(1, 1), 0);
    if (absolut) {
      frameFiltered = cv::abs(frameFiltered);
    }

    frameFiltered.convertTo(result, CV_8U);

    cv::imshow("filtroespacial", result);

    key = (char)cv::waitKey(10);
    if (key == 27) break;  // esc pressed!
    switch (key) {
      case 'a':
        absolut = !absolut;
        break;
      case 'm':
        mask = cv::Mat(3, 3, CV_32F, media);
        printmask(mask);
        break;
      case 'g':
        mask = cv::Mat(3, 3, CV_32F, gauss);
        printmask(mask);
        break;
      case 'h':
        mask = cv::Mat(3, 3, CV_32F, horizontal);
        printmask(mask);
        break;
      case 'v':
        mask = cv::Mat(3, 3, CV_32F, vertical);
        printmask(mask);
        break;
      case 'l':
        mask = cv::Mat(3, 3, CV_32F, laplacian);
        printmask(mask);
        break;
        case 'x':
        mask = cv::Mat(5, 5, CV_32F, laplgauss);
        printmask(mask);
        break;
      case 'b':
        mask = cv::Mat(3, 3, CV_32F, boost);
        break;
      default:
        break;
    }
  }
  return 0;
}
----
.Resultado
:video: figuras/resultado.mp4[width=640, opts=autoplay]


Compare o resultado desse filtro com a simples aplicação do filtro laplaciano.




