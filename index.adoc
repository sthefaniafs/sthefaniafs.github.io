= Processamento Digital de Imagens
:url-peak: https://agostinhobritojr.github.io/tutorial/pdi/exemplos/pixels.cpp
:url-peak1: https://docs.opencv.org/3.4/d2/d44/classcv_1_1Rect__.html
:url-peak2: https://agostinhobritojr.github.io/tutorial/pdi/exemplos/labeling.cpp
Por Sthefania Fernandes <sthefaniafernandes03@gmail.com> 
graduanda em Engenharia Mecatrônica pela UFRN
:toc: left
:toc-title: Sumário

== Introdução

Este site tem por objetivo documentar a solução dos exercícios da disciplina Processamento Digital de Imagens (DCA0445) ministrada pelo professor Agostinho Brito Jr. e disponível em https://agostinhobritojr.github.io/tutorial/pdi/.


Todos os exercícios foram desenvolvidos usando a API C++ do OpenCV — https://opencv.org/  — e foram testados em um ambiente executando o sistema operacional Linux (Ubuntu 20.04.6).


== 1.Manipulando pixels de uma imagem

=== 1.1 Negativo de uma região

Utilizando o programa {url-peak}[exemplos/pixels.cpp] como referência, foi implementado o programa regions.cpp. 

Esse programa irá solicitar ao usuário as coordenadas de dois pontos (P1 e P2), os quais devem localizar-se dentro do limites de tamanho da imagem. Essa região, definida pelos pontos P1 e P2, será exibida com o negativo da imagem utilizada pelo programa. 

O algoritmo desenvolvido pode ser visualizado abaixo:

.Código 1: regions.cpp

[source, cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

/*
Essa função foi feita para definir o funcionamento correto do for que tornará a imagem negativa. Afinal ele percorre do menor valor para o maior, incrementando a cada iteração, então é preciso garantir que ele inicie a contagem da menor coordenada para maior.
*/
void troca_val(int *a, int *b){

    int aux=0;

    if ((*a)>(*b)){
        aux=*a;
        *a=*b;
        *b=aux;
    }
    else
        return;
}

int main (){

    cv::Mat image;
    cv::Vec2i p1;
    cv::Vec2i p2;

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);
    if(!image.data)
        std::cout << "A imagem nao abriu" << std::endl;
    
    cv::namedWindow("Recorte negativo", cv::WINDOW_AUTOSIZE);

    std:: cout << "O tamanho da imagem é: " << image.rows << "x"<< image.cols << std:: endl;
    std:: cout << "Insira 2 pontos dentro do limite." << std:: endl;

    /*
    o do-while é utilizado para impedir que se insira uma coordenada fora do tamanho da imagem
    */

    do {
        std::cout << "Insira a coordenada x do 1º ponto:" << std:: endl;
        std::cin >> p1[0];
    } while (p1[0]>=image.rows);

    do {
        std::cout << "Insira a coordenada y do 1º ponto:" << std:: endl;
        std::cin >> p1[1];
    } while (p1[1]>=image.cols);
    
    do {
        std::cout << "Insira a coordenada x do 2º ponto:" << std:: endl;
        std::cin >> p2[0];
    } while (p2[0]>=image.rows);

    do {
        std::cout << "Insira a coordenada y do 2º ponto:" << std:: endl;
        std::cin >> p2[1];
    } while (p2[1]>=image.cols);

    /*
    se a coordenada x1 e x2  ou y1 e y2 forem iguais a condição do for não é atendida e a imagem  não ficará negativa, então se alguém preencher dessa forma o programa será encerrado com aviso de erro.
    */

    if (p1[0]==p2[0]|| p1[1]==p2[1]){
        std:: cout<< "Erro: coordenadas inválidas. x1 deve ser diferente de x2, y1 deve ser diferente de y2." << std:: endl;
        return 0;
    }

    troca_val(&p1[0],&p2[0]);
    troca_val(&p1[1],&p2[1]);
    
    for(int i=p1[0]; i<p2[0]; i++){
        for(int j=p1[1]; j<p2[1]; j++){
            image.at<uchar>(i,j)= 255 - image.at<uchar>(i,j);
        }
    }

    cv::imshow("Recorte negativo", image);  
    cv::waitKey();

    return 0;
}
----

A parte principal desse código é definir o negativo da imagem. Isso é feito subtraindo de 255 (equivalente a cor branca em uma imagem) o valor do pixel que você quer deixar negativo. Aqui os pixels que se tornarão negativos são os definidos pelos 2 pontos inseridos pelo usuário e estes são usados como inicio e fim do laço que realiza a alteração da imagem.

.Código 2: Negativo de uma imagem

[source, cpp]
----
for(int i=p1[0]; i<p2[0]; i++){
        for(int j=p1[1]; j<p2[1]; j++){
            image.at<uchar>(i,j)= 255 - image.at<uchar>(i,j);
        }
    }
----

A imagem utilizada nesse código é a mostrada abaixo:

.Imagem original
image::figuras/biel.png[]

A saída do programa será uma imagem com uma parte negativa definida pelos pontos inseridos pelo usuário. A imagem original não será alterada e ao pressionar uma tecla qualquer do teclado a imagem negativa será fechada e não será salva. 

Abaixo temos duas imagens obtidas com esse programa. A primeira utiliza os pontos (50,70)(160,30) e a segunda (50,100)(200,200).

.Resultados do algoritmo
image::figuras/negativos.png[width=500,height=500]

=== 1.2 Troca de Quadrantes

Por meio do programa {url-peak}[exemplos/pixels.cpp], foi implementado um programa que troca quatro quadrantes de uma imagem. 

No código foi utilizada a função {url-peak1}[rect] do OpenCV para extrair regiões de uma imagem. Cada região extraída foi salva em uma nova matriz (Q1, Q2, Q3,e Q4). Utilizando a função copyTo os recortes salvos foram inseridos na matriz trocaquadrante em posições diferentes da imagem original.

O algoritmo desenvolvido pode ser visualizado abaixo:

.Código 3: trocaregioes.cpp
[source, cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main (){
    /*Definindo imagem original*/
    cv::Mat image;
    /*Definindo imagem com os quadrantes mudados.
      Ela terá o mesmo número de linhas e colunas da imagem
      original e o mesmo tipo*/

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);

    if(!image.data)
        std::cout << "A imagem nao abriu" << std::endl;
    
    cv::namedWindow("Imagem original", cv::WINDOW_AUTOSIZE);
    cv::imshow("Imagem original", image);  
    cv::waitKey();

    cv::Mat trocaquadrante(image.rows, image.cols, image.type());

    /*quadrante superior esquerdo*/
    cv::Mat Q1 = image(cv::Rect(0, 0, image.rows/2, image.cols/2)); 
    /*quadrante inferior esquerdo*/
    cv::Mat Q2 = image(cv::Rect(0, image.cols/2, image.rows/2, image.cols/2));
    /*quadrante superior direito*/   
    cv::Mat Q3 = image(cv::Rect(image.rows/2, 0, image.rows/2, image.cols/2));
    /*quadrante inferior direito*/
    cv::Mat Q4 = image(cv::Rect(image.rows/2, image.cols/2, image.rows/2, image.cols/2));

    Q4.copyTo(trocaquadrante(cv::Rect(0,0,image.rows/2,image.cols/2)));
    Q3.copyTo(trocaquadrante(cv::Rect(0,image.cols/2,image.rows/2,image.cols/2)));
    Q2.copyTo(trocaquadrante(cv::Rect(image.rows/2,0,image.rows/2,image.cols/2)));
    Q1.copyTo(trocaquadrante(cv::Rect(image.rows/2,image.cols/2,image.rows/2,image.cols/2)));


    cv::namedWindow("Imagem trocada", cv::WINDOW_AUTOSIZE);
    cv::imshow("Imagem trocada", trocaquadrante);
    cv::waitKey();
   
    return 0;
}
----

Como resultado do programa, obtivemos as imagens abaixo:

.Imagem original e imagem com quadrantes trocados
image::figuras/trocarregioes.png[width=500,height=500]

=== 1.3 

=== 1.4 


=== 1.5 Identificando bolhas com ou sem buracos

Aprimorando o algoritmo {url-peak2}[labeling.cpp], o objetivo agora é identificar regiões com ou sem buracos internos que existam na imagem. Para isso, vamos assumir que objetos com mais de um buraco podem existir e que não devemos contar bolhas que tocam as bordas da imagem.

Abaixo temos o algoritmo completo que foi implementado.

.Código 4: buracosebolhas.cpp

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

using namespace cv;

int main(int argc, char** argv) {
    cv::Mat image;
    int width, height;
    int total_bolhas=0;
    int bolhas_cm_buraco=0;
    int bolhas_na_borda=0;

    cv::Point p;
    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

    if (!image.data) {
        std::cout << "imagem nao carregou corretamente\n";
        return (-1);
    }

    cv::imshow("Imagem original", image);
    cv::imwrite("original.png", image);
    cv::waitKey();

    width = image.cols;
    height = image.rows;
    std::cout << width << "x" << height << std::endl;

    p.x = 0;
    p.y = 0;

    /*
    Removendo bolhas das bordas: 
    o loop verifica os bjetos presentes nas bordas 
    e pinta de preto
    */ 
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (i == 0 || i == (height - 1) || j == 0 || j == (width - 1))
            {
                if (image.at<uchar>(i, j) == 255)
                {
                    p.x = j;
                    p.y = i;
                    bolhas_na_borda++;
                    cv::floodFill(image, p, 0);
                }
            }
        }
    }

    cv::imshow("Sem bolhas na borda", image);
    cv::imwrite("borda.png", image);
    cv::waitKey();

    /*
    Contar bolhas com buraco: primeiro mudo a cor do fundo para
    um tom de cinza (100), assim só restará a cor preta dentro
    das bolhas com buraco permitindo a contagem.
    Depois o buraco é pintado de branco
    */
    p.x = 0;
    p.y = 0;
    cv::floodFill(image, p, 100);
    cv::imshow("Bolhas com buraco", image);
    cv::imwrite("buraco.png", image);
    cv::waitKey();

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (image.at<uchar>(i, j) == 0)
            {
                p.x = j;
                p.y = i;
                bolhas_cm_buraco++;
                cv::floodFill(image, p, 255);
            }
        }
    }

    p.x = 0;
    p.y = 0;
    /*volta o fundo para a cor original (preto)*/
    cv::floodFill(image, p, 0);

    /*
    utilizando o algoritmo labeling conto o total de bolhas na imagem
    */

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (image.at<uchar>(i, j) == 255)
            {
                // achou um objeto
                total_bolhas++;
                // para o floodfill as coordenadas
                // x e y são trocadas.
                p.x = j;
                p.y = i;
                // preenche o objeto com o contador
                cv::floodFill(image, p, total_bolhas);
            }
        }
    }
    
    int bolhas_sem_buraco=total_bolhas-bolhas_cm_buraco;

    cv::imshow("Bolhas", image);
    cv::imwrite("Bolhas.png", image);
    cv::waitKey();
    
    std::cout << "Total de bolhas na imagem: " << total_bolhas << std:: endl;
    std::cout << "Bolhas com buraco: " << bolhas_cm_buraco << std:: endl;
    std::cout << "Bolhas sem buraco: " << bolhas_sem_buraco << std:: endl;
    std::cout << "Bolhas que estavam na borda: " << bolhas_na_borda << std:: endl;
    
    return 0;
}
----

A cada mudança significativa foi gerada uma imagem. Assim, começamos mostrando como é a imagem original rotulada pelo programa.

.Imagem original bolhas.png
image::figuras/bolhas.png[width=300,height=300]

Com a retirada das bolhas contidas na borda da imagem, é gerada a segunda imagem:

.Imagem sem bolhas na borda
image::figuras/semborda.png[width=300,height=300]

Para identificar quais bolhas possuíam buracos, a cor do fundo foi mudada de preto para um tom de cinza. Isso foi feito para que somente os buracos ficassem na cor preta, assim a imagem foi varrida e foi possível identificar a quantidade de bolhas com buraco.

.Bolhas com buraco
image::figuras/buracos.png[width=300,height=300]

Em adição, os buracos foram removidos e a quantidade total de bolhas restantes foi contada. Além disso, o fundo voltou a ser preto permitindo que o labeling fosse  aplicado. A imagem final gerada pode ser vista abaixo:

.Resultado final do programa
image::figuras/bolhaslab.png[width=300,height=300]

No fim, o código exibe como resposta os seguintes dados:

----
Total de bolhas na imagem: 21
Bolhas com buraco: 7
Bolhas sem buraco: 14
Bolhas que estavam na borda: 11
----